<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API documentation · BSplines.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BSplines.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../basis/">The <code>BSplineBasis</code> type</a></li><li><a class="tocitem" href="../spline/">The <code>Spline</code> type</a></li><li><a class="tocitem" href="../functions/">Higher-level functions</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li></ul></li><li class="is-active"><a class="tocitem" href>API documentation</a><ul class="internal"><li><a class="tocitem" href="#Types-and-constructors"><span>Types and constructors</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sostock/BSplines.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-documentation"><a class="docs-heading-anchor" href="#API-documentation">API documentation</a><a id="API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-documentation" title="Permalink"></a></h1><h2 id="Types-and-constructors"><a class="docs-heading-anchor" href="#Types-and-constructors">Types and constructors</a><a id="Types-and-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BSplines.AllDerivatives" href="#BSplines.AllDerivatives"><code>BSplines.AllDerivatives</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AllDerivatives{N}</code></pre><p>A singleton type that represents all <code>m</code>-th derivatives where <code>0 ≤ m &lt; N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/derivatives.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.AllDerivatives-Tuple{Integer}" href="#BSplines.AllDerivatives-Tuple{Integer}"><code>BSplines.AllDerivatives</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AllDerivatives(N)</code></pre><p>A shortcut for <code>AllDerivatives{N}()</code>, representing all <code>m</code>-th derivatives where <code>0 ≤ m &lt; N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/derivatives.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.BSpline" href="#BSplines.BSpline"><code>BSplines.BSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSpline{B} &lt;: Spline{B}</code></pre><p>Type for a B-spline from a B-spline basis of type <code>B</code>. <code>BSpline</code>s can be obtained by indexing into a B-spline basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/spline.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.BSpline-Union{Tuple{B}, Tuple{B,Integer}} where B&lt;:BSplineBasis" href="#BSplines.BSpline-Union{Tuple{B}, Tuple{B,Integer}} where B&lt;:BSplineBasis"><code>BSplines.BSpline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BSpline(basis::BSplineBasis, index)</code></pre><p>Return the <code>index</code>-th B-spline of <code>basis</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; basis = BSplineBasis(5, 1:10);

julia&gt; BSpline(basis, 3)
BSpline{BSplineBasis{UnitRange{Int64}}}:
 basis: 13-element BSplineBasis{UnitRange{Int64}}:
  order: 5
  breakpoints: 1:10
 index: 3 (knots: [1, 1, 1, 2, 3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/spline.jl#L105-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.BSplineBasis" href="#BSplines.BSplineBasis"><code>BSplines.BSplineBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSplineBasis{T&lt;:AbstractVector{&lt;:Real}}</code></pre><p>Type for a B-spline basis with breakpoint vector of type <code>T</code>.</p><p>Here, a B-spline basis is completely specified by its order <span>$k$</span> and breakpoint sequence. The knot sequence is derived from the breakpoint sequence by duplicating the first and last breakpoints so they each appear <span>$k$</span> times. Knot sequences where the first and last breakpoints do not appear <span>$k$</span> times are not supported by this data type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.BSplineBasis-Tuple{Any,Any}" href="#BSplines.BSplineBasis-Tuple{Any,Any}"><code>BSplines.BSplineBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BSplineBasis(order, breakpoints)</code></pre><p>Create a B-spline basis with order <code>order</code> and breakpoint vector <code>breakpoints</code>. The breakpoint vector is assumed to be sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.Derivative" href="#BSplines.Derivative"><code>BSplines.Derivative</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Derivative{N}</code></pre><p>A singleton type that represents the <code>N</code>-th derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/derivatives.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.Derivative-Tuple{Integer}" href="#BSplines.Derivative-Tuple{Integer}"><code>BSplines.Derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Derivative(N)</code></pre><p>A shortcut for <code>Derivative{N}()</code>, representing the <code>N</code>-th derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/derivatives.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.Spline" href="#BSplines.Spline"><code>BSplines.Spline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Spline{B&lt;:BSplineBasis, C&lt;:AbstractVector{&lt;:Real}}</code></pre><p>Type for a spline based on a B-spline basis of type <code>B</code> and coefficient vector of type <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/spline.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.Spline-Tuple{Any,Any}" href="#BSplines.Spline-Tuple{Any,Any}"><code>BSplines.Spline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Spline(basis, coeffs)</code></pre><p>Create a spline from a B-spline basis and a vector of coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/spline.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Function" href="#Core.Function"><code>Core.Function</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Function(spline::Spline, [deriv::Derivative], [onlysupport=true])</code></pre><p>Wrap <code>spline</code> in an object that is a subtype of <code>Function</code>. Calling the returned function with a single argument <code>x</code> will evaluate the spline (or one of its derivatives as specified by <code>deriv</code>) at <code>x</code>.</p><p>If the optional argument <code>onlysupport</code> is set to <code>true</code> (the default), the returned function will return <code>NaN</code> if evaluated outside of the <a href="#BSplines.support"><code>support</code></a> of <code>spline</code>. If <code>onlysupport</code> is set to <code>false</code>, it will return zero there (as does calling the <code>spline</code> directly).</p><p>Note that a <code>Spline</code> can be called without wrapping them as described here, although they are not a subtype of <code>Function</code>. Wrapping a spline in a <code>Function</code> object is mainly intended to aid in plotting, which is the rationale behind the <code>onlysupport=true</code> default: when using <a href="https://github.com/JuliaPlots/Plots.jl"><code>Plots.jl</code></a>, this will cause the spline to not be drawn outside of its support.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; spline = approximate(sin, BSplineBasis(5, 0:5)); # create a Spline

julia&gt; f = Function(spline, false); # f is zero outside of the interval [0,5]

julia&gt; g = Function(spline, Derivative(1)); # g is NaN outside of the interval [0,5]

julia&gt; f(1.5) == spline(1.5)
true

julia&gt; g(1.5) == spline(1.5, Derivative(1))
true

julia&gt; f(-1), g(-1)
(0.0, NaN)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/plotting.jl#L39-L75">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BSplines.approximate" href="#BSplines.approximate"><code>BSplines.approximate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">approximate(f, basis::BSplineBasis; indices=eachindex(basis)) -&gt; Spline</code></pre><p>Approximate the function <code>f</code> in the B-spline basis <code>basis</code>. If <code>indices</code> is supplied, only the basis functions at the given indices of <code>basis</code> are used.</p><p>The approximation is calculated by interpolating samples of <code>f</code> at the <a href="#BSplines.knotaverages"><code>knotaverages</code></a> of the basis.</p><p>See also: <a href="#BSplines.interpolate"><code>interpolate</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; basis = BSplineBasis(5, 0:5);

julia&gt; spl = approximate(sin, basis, indices=2:length(basis))
Spline{BSplineBasis{UnitRange{Int64}},Array{Float64,1}}:
 basis: 9-element BSplineBasis{UnitRange{Int64}}:
  order: 5
  breakpoints: 0:5
 coeffs: [0.0, 0.249631, 0.75251, 1.22974, 0.738521, -0.432817, -1.01254, -1.02969, -0.958924]

julia&gt; spl(π/4)
0.7071028397621081</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/BSplines.jl#L57-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.averagebasis" href="#BSplines.averagebasis"><code>BSplines.averagebasis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">averagebasis(order, datapoints) -&gt; BSplineBasis</code></pre><p>Returns a B-spline basis with the specified <code>order</code> that is well-suited for interpolation on the given <code>datapoints</code>. The <code>datapoints</code> vector is assumed to be sorted.</p><p>The calculated breakpoints are described in <sup class="footnote-reference"><a id="citeref-deBoor1978" href="#footnote-deBoor1978">[deBoor1978]</a></sup>, p. 219, as a “reasonable alternative” to the optimal breakpoint sequence since they are “often very close to the optimum” and are computationally inexpensive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; averagebasis(5, 0:10)
11-element BSplineBasis{Array{Float64,1}}:
 order: 5
 breakpoints: [0.0, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 10.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/BSplines.jl#L250-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.basis" href="#BSplines.basis"><code>BSplines.basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">basis(spline::Spline)</code></pre><p>Return the B-spline basis on which the spline is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/spline.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.basismatrix" href="#BSplines.basismatrix"><code>BSplines.basismatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">basismatrix(basis::BSplineBasis, xvalues; indices=eachindex(basis))</code></pre><p>Calculate the matrix <code>[basis[i](x) for x=xvalues, i=indices]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; basis = BSplineBasis(3, 0:5);

julia&gt; x = [0.3, 1.5, 3.2, 4.5];

julia&gt; basismatrix(basis, x)
4×7 Array{Float64,2}:
 0.49  0.465  0.045  0.0    0.0    0.0    0.0
 0.0   0.125  0.75   0.125  0.0    0.0    0.0
 0.0   0.0    0.0    0.32   0.66   0.02   0.0
 0.0   0.0    0.0    0.0    0.125  0.625  0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L717-L736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.basismatrix!" href="#BSplines.basismatrix!"><code>BSplines.basismatrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">basismatrix!(dest, basis::BSplineBasis, xvalues; indices=eachindex(basis))</code></pre><p>Calculate the matrix <code>[basis[i](x) for x=xvalues, i=indices]</code> and store it in <code>dest</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; basis = BSplineBasis(3, 0:5);

julia&gt; x = [0.3, 1.5, 3.2, 4.5];

julia&gt; dest = Array{Float64}(undef, length(x), length(basis));

julia&gt; basismatrix!(dest, basis, x)
4×7 Array{Float64,2}:
 0.49  0.465  0.045  0.0    0.0    0.0    0.0
 0.0   0.125  0.75   0.125  0.0    0.0    0.0
 0.0   0.0    0.0    0.32   0.66   0.02   0.0
 0.0   0.0    0.0    0.0    0.125  0.625  0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L746-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.breakpoints" href="#BSplines.breakpoints"><code>BSplines.breakpoints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">breakpoints(basis::BSplineBasis)</code></pre><p>Return the breakpoint sequence of the B-spline basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; breakpoints(BSplineBasis(3, 0:5))
0:5

julia&gt; breakpoints(BSplineBasis(4, [1.0, 1.5, 2.5, 4.0]))
4-element Array{Float64,1}:
 1.0
 1.5
 2.5
 4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L71-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.bsplines!" href="#BSplines.bsplines!"><code>BSplines.bsplines!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bsplines!(dest, basis, x, [::Derivative{N}]; leftknot=intervalindex(basis, x))</code></pre><p>Calculate the values of all non-zero B-splines of <code>basis</code>, or their <code>N</code>-th derivatives, at <code>x</code> in-place (i.e., in <code>dest</code>). The destination vector <code>dest</code> must have the length <code>order(basis)</code>.</p><p>If any B-splines are non-zero at <code>x</code>, return an <code>OffsetVector</code> that wraps <code>dest</code> and contains the value of the <code>i</code>-th B-spline (or its <code>N</code>-th derivative) at the index <code>i</code>. If no B-splines are non-zero at <code>x</code>, return <code>nothing</code>.</p><p>If the index of the relevant interval is already known, it can be supplied with the optional <code>leftknot</code> keyword to speed up the calculation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dest = zeros(4);

julia&gt; bsplines!(dest, BSplineBasis(4, 0:5), 2.4)
4-element OffsetArray(::Array{Float64,1}, 3:6) with eltype Float64 with indices 3:6:
 0.03600000000000002
 0.5386666666666667
 0.41466666666666663
 0.01066666666666666

julia&gt; parent(ans) === dest
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L493-L522">source</a></section><section><div><pre><code class="language-none">bsplines!(dest, basis, x, ::AllDerivatives{N}; leftknot=intervalindex(basis, x))</code></pre><p>Calculate all <code>m</code>-th derivatives (<code>0 ≤ m &lt; N</code>) of all non-zero B-splines of <code>basis</code> at <code>x</code> in-place (i.e., in <code>dest</code>). The destination matrix <code>dest</code> must have the size <code>(order(basis), N)</code>.</p><p>If any B-splines are non-zero at <code>x</code>, return an <code>OffsetMatrix</code> that wraps <code>dest</code> and contains the <code>m</code>-th derivative of the <code>i</code>-th B-spline at the index <code>i, m</code>. If no B-splines are non-zero at <code>x</code>, return <code>nothing</code>.</p><p>If the index of the relevant interval is already known, it can be supplied with the optional <code>leftknot</code> keyword to speed up the calculation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dest = zeros(4, 3);

julia&gt; bsplines!(dest, BSplineBasis(4, 0:5), -1.0, AllDerivatives(3)) # returns nothing

julia&gt; bsplines!(dest, BSplineBasis(4, 0:5), 3.75, AllDerivatives(3))
4×3 OffsetArray(::Array{Float64,2}, 4:7, 0:2) with eltype Float64 with indices 4:7×0:2:
 0.00260417  -0.03125    0.25
 0.315104    -0.65625    0.25
 0.576823     0.265625  -1.625
 0.105469     0.421875   1.125

julia&gt; parent(ans) === dest
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L525-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.bsplines" href="#BSplines.bsplines"><code>BSplines.bsplines</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bsplines(basis, x, [::Derivative{N}]; leftknot=intervalindex(basis, x))</code></pre><p>Calculate the values of all non-zero B-splines of <code>basis</code>, or their <code>N</code>-th derivatives, at <code>x</code>.</p><p>If any B-splines are non-zero at <code>x</code>, return an <code>OffsetVector</code> that contains the value of the <code>i</code>-th B-spline (or its <code>N</code>-th derivative) at the index <code>i</code>. If no B-splines are non-zero at <code>x</code>, return <code>nothing</code>.</p><p>If the index of the relevant interval is already known, it can be supplied with the optional <code>leftknot</code> keyword to speed up the calculation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; basis = BSplineBasis(4, 0:5);

julia&gt; bsplines(basis, 2.4)
4-element OffsetArray(::Array{Float64,1}, 3:6) with eltype Float64 with indices 3:6:
 0.03600000000000002
 0.5386666666666667 
 0.41466666666666663
 0.01066666666666666

julia&gt; bsplines(basis, 2.4, Derivative(1))
4-element OffsetArray(::Array{Float64,1}, 3:6) with eltype Float64 with indices 3:6:
 -0.18000000000000005
 -0.5599999999999999
  0.66
  0.07999999999999996

julia&gt; bsplines(basis, 6) # returns nothing

julia&gt; bsplines(basis, 17//5, leftknot=7)
4-element OffsetArray(::Array{Rational{Int64},1}, 4:7) with eltype Rational{Int64} with indices 4:7:
   9//250
 202//375
 307//750
   2//125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L416-L457">source</a></section><section><div><pre><code class="language-none">bsplines(basis, x, ::AllDerivatives{N}; leftknot=intervalindex(basis, x))</code></pre><p>Calculate all <code>m</code>-th derivatives (<code>0 ≤ m &lt; N</code>) of all non-zero B-splines of <code>basis</code> at <code>x</code>.</p><p>If any B-splines are non-zero at <code>x</code>, return an <code>OffsetMatrix</code> that contains the <code>m</code>-th derivative of the <code>i</code>-th B-spline at the index <code>i, m</code>. If no B-splines are non-zero at <code>x</code>, return <code>nothing</code>.</p><p>If the index of the relevant interval is already known, it can be supplied with the optional <code>leftknot</code> keyword to speed up the calculation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bsplines(BSplineBasis(3, 0:5), 2.4, AllDerivatives(3))
3×3 OffsetArray(::Array{Float64,2}, 3:5, 0:2) with eltype Float64 with indices 3:5×0:2:
 0.18  -0.6   1.0
 0.74   0.2  -2.0
 0.08   0.4   1.0

julia&gt; bsplines(BSplineBasis(3, 0:5), 6.0, AllDerivatives(3)) # returns nothing

julia&gt; bsplines(BSplineBasis(4, 0:5), 17//5, AllDerivatives(4), leftknot=7)
4×4 OffsetArray(::Array{Rational{Int64},2}, 4:7, 0:3) with eltype Rational{Int64} with indices 4:7×0:3:
   9//250   -9//50   3//5  -1//1
 202//375  -14//25  -4//5   3//1
 307//750   31//50  -2//5  -7//2
   2//125    3//25   3//5   3//2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L460-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.coeffs" href="#BSplines.coeffs"><code>BSplines.coeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coeffs(spline::Spline)</code></pre><p>Return the coefficient vector of <code>spline</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/spline.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.interpolate" href="#BSplines.interpolate"><code>BSplines.interpolate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interpolate(basis::BSplineBasis, xvalues, yvalues; indices=eachindex(basis)) -&gt; Spline</code></pre><p>Interpolate the data given by <code>xvalues</code> and <code>yvalues</code> in the B-spline basis <code>basis</code>. If <code>indices</code> is supplied, only the basis functions at the given indices of <code>basis</code> are used.</p><p>The spline interpolation is calculated by creating the matrix <code>B = [basis[i](x) for x=xvalues, i=indices]</code> and then calculating <code>B\yvalues</code>.</p><p>See also: <a href="#BSplines.approximate"><code>approximate</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; basis = BSplineBasis(5, 1:10);

julia&gt; xs = range(1, stop=10, length=length(basis)); ys = log.(xs);

julia&gt; spl = interpolate(basis, xs, ys)
Spline{BSplineBasis{UnitRange{Int64}},Array{Float64,1}}:
 basis: 13-element BSplineBasis{UnitRange{Int64}}:
  order: 5
  breakpoints: 1:10
 coeffs: [0.0, 0.248019, 0.596872, 0.946671, 1.26894, 1.51405, 1.71149, 1.87666, 2.01856, 2.14292, 2.22592, 2.27758, 2.30259]

julia&gt; spl(float(ℯ))
0.9999766059171411</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/BSplines.jl#L89-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.intervalindex" href="#BSplines.intervalindex"><code>BSplines.intervalindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intervalindex(vec, x[, start])</code></pre><p>If <code>v</code> is an <code>AbstractVector</code>, return the largest index <code>i</code> so that <code>vec[i] ≤ x</code> and <code>vec[i] &lt; vec[end]</code>. Return <code>nothing</code> if <code>x &lt; first(vec)</code> or <code>x &gt; last(vec)</code> or <code>isnan(x)</code>. The vector <code>vec</code> is assumed to be sorted in ascending order.</p><p>If <code>vec</code> is a <a href="#BSplines.BSplineBasis"><code>BSplineBasis</code></a>, return <code>intervalindex(knots(vec), x[, start])</code>.</p><p>If <code>start</code> is given, a linear search is performed, starting from the index <code>start</code> going forward or backward. If <code>start</code> is not given, a binary search is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intervalindex([1,1,2,3,4,4,4,5,6,6], 2.5)
3

julia&gt; intervalindex([1,1,2,3,4,4,4,5,6,6], 7) # returns nothing

julia&gt; intervalindex([1,1,2,3,4,4,4,5,6,6], 1)
2

julia&gt; intervalindex([1,1,2,3,4,4,4,5,6,6], 4)
7

julia&gt; intervalindex([1,1,2,3,4,4,4,5,6,6], 6.0)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L139-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.intervalindices" href="#BSplines.intervalindices"><code>BSplines.intervalindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intervalindices(basis::BSplineBasis, indices=eachindex(basis))</code></pre><p>Return an iterator that yields the indices of all intervals on which <code>basis</code> is defined, i.e., it produces all indices <code>ind</code> (in ascending order) for which <code>(knots(basis)[ind], knots(basis)[ind+1])</code> is such an interval. </p><p>If a range of <code>indices</code> is supplied, the iterator yields only those intervals on which <em>at least one</em> of the B-splines <code>basis[j] for j=indices</code> is non-zero.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intervalindices(BSplineBasis(3, 0:5))
3:7

julia&gt; intervalindices(BSplineBasis(3, 0:5), 1:4)
3:6

julia&gt; intervalindices(BSplineBasis(4, [1,2,3,4,4,4,5,6]))
BSplines.IntervalIndices{Array{Int64,1}}([1, 2, 3, 4, 4, 4, 5, 6], 1:8, 3)

julia&gt; collect(ans)
5-element Array{Int64,1}:
  4
  5
  6
  9
 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L293-L323">source</a></section><section><div><pre><code class="language-none">intervalindices(basis::BSplineBasis, i, j, ...)</code></pre><p>For integers <code>i</code>, <code>j</code>, …, return an iterator that yields the indices of all intervals on which <em>all</em> of the B-splines <code>basis[i]</code>, <code>basis[j]</code>, … are non-zero, i.e., it produces all indices <code>ind</code> (in ascending order) for which <code>(knots(basis)[ind], knots(basis)[ind+1])</code> is such an interval.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intervalindices(BSplineBasis(3, 0:5), 3)
3:5

julia&gt; intervalindices(BSplineBasis(3, 0:5), 4, 5)
5:6

julia&gt; intervalindices(BSplineBasis(3, 0:5), 2, 6) # B-splines do not overlap
6:5

julia&gt; intervalindices(BSplineBasis(3, 0:5), 3, 5, 4)
5:5

julia&gt; intervalindices(BSplineBasis(4, [1,2,3,4,4,4,5,6]), 3, 5)
BSplines.IntervalIndices{Array{Int64,1}}([1, 2, 3, 4, 4, 4, 5, 6], 2:4, 3)

julia&gt; collect(ans)
2-element Array{Int64,1}:
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L344-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.knotaverages!" href="#BSplines.knotaverages!"><code>BSplines.knotaverages!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">knotaverages!(dest, basis::BSplineBasis; indices=eachindex(basis))</code></pre><p>Calculate the knot averages <code>τ[i] = mean(knots[i+1:i+order-1])</code> for <code>i ∈ indices</code> and the knots and order of <code>basis</code> and store the result in <code>dest</code>. The knot averages are recommended in <sup class="footnote-reference"><a id="citeref-deBoor1978" href="#footnote-deBoor1978">[deBoor1978]</a></sup> (p. 214) as data points for interpolation.</p><p>See also: <a href="#BSplines.knotaverages"><code>knotaverages</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dest = Vector{Float64}(undef, 7);

julia&gt; knotaverages!(dest, BSplineBasis(3, 0:5))
7-element Array{Float64,1}:
 0.0
 0.5
 1.5
 2.5
 3.5
 4.5
 5.0

julia&gt; dest = Vector{Rational{Int}}(undef, 5);

julia&gt; knotaverages!(dest, BSplineBasis(3, 0:5), indices=2:6)
5-element Array{Rational{Int64},1}:
 1//2
 3//2
 5//2
 7//2
 9//2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/BSplines.jl#L182-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.knotaverages" href="#BSplines.knotaverages"><code>BSplines.knotaverages</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">knotaverages(basis::BSplineBasis; indices=eachindex(basis))</code></pre><p>Return the knot averages <code>τ[i] = mean(knots[i+1:i+order-1])</code> for <code>i ∈ indices</code> and the knots and order of <code>basis</code>. The knot averages are recommended in <sup class="footnote-reference"><a id="citeref-deBoor1978" href="#footnote-deBoor1978">[deBoor1978]</a></sup> (p. 214) as data points for interpolation.</p><p>See also: <a href="#BSplines.knotaverages!"><code>knotaverages!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; knotaverages(BSplineBasis(3, 0:5))
7-element Array{Float64,1}:
 0.0
 0.5
 1.5
 2.5
 3.5
 4.5
 5.0

julia&gt; knotaverages(BSplineBasis(4, [1, 3//2, 5//2, 4]), indices=2:6)
5-element Array{Rational{Int64},1}:
 7//6
 5//3
 8//3
 7//2
 4//1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/BSplines.jl#L139-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.knots" href="#BSplines.knots"><code>BSplines.knots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">knots(basis::BSplineBasis)</code></pre><p>Return the knot sequence of the B-spline basis.</p><p>The knot sequence is the breakpoint sequence except that the first and last values are duplicated so they appear <code>order(basis)</code> times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; knots(BSplineBasis(3, 0:5))
10-element BSplines.KnotVector{Int64,UnitRange{Int64}}:
 0
 0
 0
 1
 2
 3
 4
 5
 5
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L92-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.order" href="#BSplines.order"><code>BSplines.order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">order(spline::Spline)
order(basis::BSplineBasis)</code></pre><p>Return the order of a spline or a B-spline basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; order(BSplineBasis(3, 0:5))
3

julia&gt; order(BSplineBasis(4, [1.0, 1.5, 2.5, 4.0]))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L119-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.splinevalue" href="#BSplines.splinevalue"><code>BSplines.splinevalue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">splinevalue(spline::Spline, x, [::Derivative{N}]; kwargs...)</code></pre><p>Calculate the value of <code>spline</code>, or its <code>N</code>-th derivative, at <code>x</code>.</p><p>Two optional keyword arguments can be used to increase performance:</p><ul><li><code>leftknot</code>: If the index of the relevant interval (i.e., <code>intervalindex(basis(spline), x)</code>) is already known, it can be supplied with the <code>leftknot</code> keyword.</li><li><code>workspace</code>: By default, the function allocates a vector of length <code>order(spline)</code> in which the calculation is performed. To avoid this, a pre-allocated vector can be supplied with the <code>workspace</code> keyword. In this case, the returned value is always of type <code>eltype(workspace)</code>.</li></ul><p>Instead of calling <code>splinevalue</code>, a spline object can be called directly: <code>spline(x, [deriv]; kwargs...)</code> is equivalent to <code>splinevalue(spline, x, [deriv]; kwargs...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; spl = Spline(BSplineBasis(4, 0:5), 1:8);

julia&gt; splinevalue(spl, 1.7)
3.69775

julia&gt; splinevalue(spl, 1.7, Derivative(1))
1.0225

julia&gt; splinevalue(spl, 3.6, leftknot=7)
5.618

julia&gt; spl(18//5)
2809//500

julia&gt; spl(3.6, Derivative(3), leftknot=7)
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/spline.jl#L162-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplines.support" href="#BSplines.support"><code>BSplines.support</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">support(basis::BSplineBasis) -&gt; a, b</code></pre><p>Return the interval <span>$[a,b]$</span> on which the B-spline basis is defined, i.e., <code>a</code> is the first and <code>b</code> the last breakpoint of the <code>basis</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; support(BSplineBasis(3, 0:5))
(0, 5)

julia&gt; support(BSplineBasis(4, [1.0, 1.5, 2.5, 4.0]))
(1.0, 4.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/bsplinebasis.jl#L398-L413">source</a></section><section><div><pre><code class="language-none">support(spline::Spline) -&gt; a, b</code></pre><p>If <code>spline</code> is a <code>BSpline</code>, return the interval <span>$[a,b]$</span> on which the B-spline is non-zero. Otherwise, return <code>support(basis(spline))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; basis = BSplineBasis(3, 0:5);

julia&gt; spline = Spline(basis, ones(7));

julia&gt; zerospline = Spline(basis, zeros(7));

julia&gt; support(spline)
(0, 5)

julia&gt; support(zerospline) # even though the spline is zero everywhere
(0, 5)

julia&gt; support(basis[4]) # for BSplines, return their actual support
(1, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sostock/BSplines.jl/blob/4287c0801799360fa8d4e54b6c03cb55c90d3e75/src/spline.jl#L134-L158">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-deBoor1978"><a class="tag is-link" href="#citeref-deBoor1978">deBoor1978</a>Carl de Boor, <em>A Practical Guide to Splines</em>, New York, N.Y.: Springer, 1978.</li><li class="footnote" id="footnote-deBoor1978"><a class="tag is-link" href="#citeref-deBoor1978">deBoor1978</a>Carl de Boor, <em>A Practical Guide to Splines</em>, New York, N.Y.: Springer, 1978.</li><li class="footnote" id="footnote-deBoor1978"><a class="tag is-link" href="#citeref-deBoor1978">deBoor1978</a>Carl de Boor, <em>A Practical Guide to Splines</em>, New York, N.Y.: Springer, 1978.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plotting/">« Plotting</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 18 August 2020 13:41">Tuesday 18 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
